<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ghost Runner Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
        }
        
        #instructions {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            z-index: 1000;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        
        #levelInfo {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 16px;
            z-index: 1000;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid white;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            z-index: 900;
            pointer-events: none;
        }
        
        .damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0.3);
            z-index: 800;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }
        
        .damage-overlay.active {
            opacity: 1;
        }
        
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            z-index: 2000;
        }
        
        @keyframes swordSlash {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.3) rotate(360deg); }
        }
        
        @keyframes shieldBlock {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.8) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.5) rotate(90deg); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.5) rotate(180deg); }
        }
    </style>
</head>
<body>
    <div id="loadingScreen">Loading 3D Ghost Adventure...</div>
    
    <div id="gameContainer"></div>
    
    <div class="crosshair"></div>
    <div class="damage-overlay" id="damageOverlay"></div>
    
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Ghosts Caught: <span id="ghostCount">0</span> / 100</div>
        <div>Health: <span id="health">100</span></div>
        <div>‚öîÔ∏è Golden Sword | üõ°Ô∏è Shield</div>
    </div>
    
    <div id="levelInfo">
        <div>Floor: <span id="currentFloor">Garden</span></div>
        <div>Ghosts Nearby: <span id="floorGhosts">4</span></div>
    </div>
    
    <div id="instructions">
        WASD/Arrow Keys: Move ‚Ä¢ SPACE/J: Jump ‚Ä¢ Mouse: Look Around ‚Ä¢ Click: Catch Ghost ‚Ä¢ Find stairs to change floors
    </div>

    <!-- Three.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Game variables
        let scene, camera, renderer;
        let player, controls;
        let currentFloor = 0; // 0: Garden, 1: Floor1, 2: Floor2
        let score = 0;
        let ghostsCaught = 0;
        let health = 100;
        
        let floors = [];
        let ghosts = [];
        let walls = [];
        let stairs = [];
        
        const keys = {};
        const moveSpeed = 0.3;
        const mouse = { x: 0, y: 0 };
        let isMouseLocked = false;
        let isJumping = false;
        let jumpVelocity = 0;
        const jumpPower = 0.5;
        const gravity = -0.02;
        
        // Camera rotation variables
        let cameraRotationX = 0;
        let cameraRotationY = 0;
        
        // Health system
        let invulnerable = false;
        let lastDamageTime = 0;
        
        // Floor configurations
        const floorConfigs = [
            { name: 'Garden', y: 0, color: 0x2d4a22 },
            { name: 'First Floor', y: 8, color: 0x8B4513 },
            { name: 'Second Floor', y: 16, color: 0x654321 }
        ];
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a2e, 0.1, 100);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x1a1a2e);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create player
            createPlayer();
            
            // Build the house
            buildHouse();
            
            // Add event listeners
            setupEventListeners();
            
            // Hide loading screen
            document.getElementById('loadingScreen').style.display = 'none';
            
            // Start game loop
            animate();
        }
        
        function createPlayer() {
            // Create invisible player collision box
            const playerGeometry = new THREE.BoxGeometry(1, 2, 1);
            const playerMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x4A90E2,
                transparent: true,
                opacity: 0 // Make player invisible
            });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 1, 0);
            scene.add(player);
        }
        
        function buildHouse() {
            // Create floors
            floorConfigs.forEach((config, index) => {
                createFloor(config, index);
            });
            
            // Create walls and rooms for each floor
            createWalls();
            
            // Create stairs
            createStairs();
            
            // Spawn ghosts
            spawnAllGhosts();
        }
        
        function createFloor(config, floorIndex) {
            const floorGeometry = new THREE.PlaneGeometry(40, 30);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: config.color });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = config.y;
            floor.receiveShadow = true;
            scene.add(floor);
            floors.push(floor);
        }
        
        function createWalls() {
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            // Garden level walls (perimeter)
            createWall(-20, 4, 0, 2, 8, 30, wallMaterial); // Left
            createWall(20, 4, 0, 2, 8, 30, wallMaterial);  // Right
            createWall(0, 4, -15, 40, 8, 2, wallMaterial); // Back
            createWall(0, 4, 15, 40, 8, 2, wallMaterial);  // Front
            
            // First floor walls
            createWall(-15, 12, 0, 2, 8, 25, wallMaterial);
            createWall(15, 12, 0, 2, 8, 25, wallMaterial);
            createWall(0, 12, -12, 30, 8, 2, wallMaterial);
            createWall(0, 12, 12, 30, 8, 2, wallMaterial);
            
            // Room dividers on first floor
            createWall(-5, 12, 0, 2, 8, 15, wallMaterial);
            createWall(5, 12, 0, 2, 8, 15, wallMaterial);
            
            // Second floor walls
            createWall(-12, 20, 0, 2, 8, 20, wallMaterial);
            createWall(12, 20, 0, 2, 8, 20, wallMaterial);
            createWall(0, 20, -10, 24, 8, 2, wallMaterial);
            createWall(0, 20, 10, 24, 8, 2, wallMaterial);
        }
        
        function createWall(x, y, z, width, height, depth, material) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            const wall = new THREE.Mesh(wallGeometry, material);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            scene.add(wall);
            walls.push(wall);
        }
        
        function createStairs() {
            const stairMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            // Stairs from garden to floor 1
            const stairs1 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), stairMaterial);
            stairs1.position.set(8, 0.5, 10);
            stairs1.userData = { from: 0, to: 1 };
            scene.add(stairs1);
            stairs.push(stairs1);
            
            // Stairs from floor 1 to floor 2
            const stairs2 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), stairMaterial);
            stairs2.position.set(-8, 8.5, 8);
            stairs2.userData = { from: 1, to: 2 };
            scene.add(stairs2);
            stairs.push(stairs2);
            
            // Stairs from floor 2 back to floor 1
            const stairs3 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), stairMaterial);
            stairs3.position.set(8, 16.5, -8);
            stairs3.userData = { from: 2, to: 1 };
            scene.add(stairs3);
            stairs.push(stairs3);
            
            // Stairs from floor 1 back to garden
            const stairs4 = new THREE.Mesh(new THREE.BoxGeometry(3, 1, 3), stairMaterial);
            stairs4.position.set(-8, 8.5, -8);
            stairs4.userData = { from: 1, to: 0 };
            scene.add(stairs4);
            stairs.push(stairs4);
        }
        
        function spawnAllGhosts() {
            // Clear existing ghosts
            ghosts.forEach(ghost => scene.remove(ghost));
            ghosts = [];
            
            // 100 ghosts scattered around the house - distributed across all floors
            const ghostPositions = [];
            
            // Ground floor ghosts (30)
            for (let i = 0; i < 30; i++) {
                const x = (Math.random() - 0.5) * 35;
                const z = (Math.random() - 0.5) * 25;
                ghostPositions.push([x, 1, z]);
            }
            
            // First floor ghosts (50)
            for (let i = 0; i < 50; i++) {
                const x = (Math.random() - 0.5) * 35;
                const z = (Math.random() - 0.5) * 25;
                ghostPositions.push([x, 9, z]);
            }
            
            // Second floor ghosts (20)
            for (let i = 0; i < 20; i++) {
                const x = (Math.random() - 0.5) * 35;
                const z = (Math.random() - 0.5) * 25;
                ghostPositions.push([x, 17, z]);
            }
            
            ghostPositions.forEach((pos, index) => {
                const floor = pos[1] === 1 ? 0 : (pos[1] === 9 ? 1 : 2);
                createGhost(pos[0], pos[1], pos[2], floor);
            });
            
            updateGhostVisibility();
        }
        
        function createGhost(x, y, z, floor) {
            const ghostGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const ghostMaterial = new THREE.MeshLambertMaterial({ 
                color: 0xffffff, 
                transparent: true, 
                opacity: 0.8 
            });
            const ghost = new THREE.Mesh(ghostGeometry, ghostMaterial);
            ghost.position.set(x, y, z);
            ghost.userData = { 
                floor: floor,
                originalY: y,
                time: Math.random() * Math.PI * 2,
                caught: false,
                chaseSpeed: 0.02 + Math.random() * 0.01 // Random chase speed between 0.02-0.03
            };
            ghost.castShadow = true;
            scene.add(ghost);
            ghosts.push(ghost);
        }
        
        function updateGhostVisibility() {
            ghosts.forEach(ghost => {
                ghost.visible = ghost.userData.floor === currentFloor && !ghost.userData.caught;
            });
        }
        
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
            
            // Mouse events
            document.addEventListener('click', onMouseClick);
            document.addEventListener('mousemove', onMouseMove);
            
            // Pointer lock
            renderer.domElement.addEventListener('click', () => {
                renderer.domElement.requestPointerLock();
            });
            
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === renderer.domElement;
            });
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        function onMouseMove(event) {
            if (!isMouseLocked) return;
            
            const sensitivity = 0.002;
            cameraRotationY -= event.movementX * sensitivity;
            cameraRotationX -= event.movementY * sensitivity;
            
            // Clamp vertical rotation
            cameraRotationX = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotationX));
            
            // Apply rotation to camera
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotationY;
            camera.rotation.x = cameraRotationX;
            camera.rotation.z = 0;
        }
        
        function onMouseClick() {
            // Raycaster for ghost catching
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            
            const visibleGhosts = ghosts.filter(ghost => ghost.visible && !ghost.userData.caught);
            const intersects = raycaster.intersectObjects(visibleGhosts);
            
            if (intersects.length > 0) {
                const ghost = intersects[0].object;
                catchGhost(ghost);
            }
        }
        
        function catchGhost(ghost) {
            ghost.userData.caught = true;
            ghost.visible = false;
            
            // Golden sword gives bonus points!
            score += 25; // Increased from 10 to 25 with golden sword
            ghostsCaught++;
            
            // Create sword slash effect
            createSwordSlashEffect(ghost.position);
            
            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('ghostCount').textContent = ghostsCaught;
            
            // Update floor ghost count
            const remainingGhosts = ghosts.filter(g => g.userData.floor === currentFloor && !g.userData.caught).length;
            document.getElementById('floorGhosts').textContent = remainingGhosts;
            
            // Check for victory
            if (ghostsCaught >= 100) {
                setTimeout(() => {
                    alert(`üéâ CONGRATULATIONS! üéâ\n\nYou caught all 100 ghosts!\nFinal Score: ${score} points\nHealth Remaining: ${health}/100\n\nYou are the ultimate Ghost Hunter!`);
                }, 500);
            }
        }
        
        function createSwordSlashEffect(position) {
            // Create golden sparkle effect at ghost position
            for (let i = 0; i < 10; i++) {
                const sparkle = document.createElement('div');
                sparkle.style.position = 'fixed';
                sparkle.style.left = '50%';
                sparkle.style.top = '50%';
                sparkle.style.color = 'gold';
                sparkle.style.fontSize = '20px';
                sparkle.style.pointerEvents = 'none';
                sparkle.style.zIndex = '1000';
                sparkle.textContent = '‚öîÔ∏è‚ú®';
                sparkle.style.animation = `swordSlash 0.8s ease-out forwards`;
                sparkle.style.transform = `translate(-50%, -50%) translate(${(Math.random()-0.5)*100}px, ${(Math.random()-0.5)*100}px)`;
                document.body.appendChild(sparkle);
                
                setTimeout(() => sparkle.remove(), 800);
            }
        }
        
        function updatePlayer() {
            const direction = new THREE.Vector3();
            
            if (keys['KeyW'] || keys['ArrowUp']) direction.z -= 1;
            if (keys['KeyS'] || keys['ArrowDown']) direction.z += 1;
            if (keys['KeyA'] || keys['ArrowLeft']) direction.x -= 1;
            if (keys['KeyD'] || keys['ArrowRight']) direction.x += 1;
            
            // Jump mechanics
            if ((keys['Space'] || keys['KeyJ']) && !isJumping) {
                jumpVelocity = jumpPower;
                isJumping = true;
            }
            
            if (direction.length() > 0) {
                direction.normalize();
                
                // Apply only Y rotation (left/right) to movement, ignore X rotation (up/down)
                const yRotation = new THREE.Quaternion();
                yRotation.setFromAxisAngle(new THREE.Vector3(0, 1, 0), cameraRotationY);
                direction.applyQuaternion(yRotation);
                
                player.position.add(direction.multiplyScalar(moveSpeed));
            }
            
            // Apply jump physics
            if (isJumping) {
                player.position.y += jumpVelocity;
                jumpVelocity += gravity;
                
                // Check if landed back on floor
                const floorY = currentFloor === 0 ? 1 : (currentFloor === 1 ? 9 : 17);
                if (player.position.y <= floorY) {
                    player.position.y = floorY;
                    isJumping = false;
                    jumpVelocity = 0;
                }
            }
            
            // Keep camera with player
            camera.position.copy(player.position);
            camera.position.y = player.position.y + 1.5;
            
            // Check ghost collisions (damage)
            checkGhostCollisions();
            
            // Check stairs
            checkStairs();
            
            // Keep player within bounds
            const bounds = 18;
            player.position.x = Math.max(-bounds, Math.min(bounds, player.position.x));
            player.position.z = Math.max(-13, Math.min(13, player.position.z));
        }
        
        function checkGhostCollisions() {
            if (invulnerable) return;
            
            const currentTime = Date.now();
            ghosts.forEach(ghost => {
                if (ghost.visible && !ghost.userData.caught && ghost.userData.floor === currentFloor) {
                    const distance = player.position.distanceTo(ghost.position);
                    if (distance < 1.5) { // Ghost catches player
                        takeDamage();
                    }
                }
            });
        }
        
        function takeDamage() {
            // Shield reduces damage by 75%!
            const damage = Math.random() < 0.75 ? 0 : 1; // 75% chance to block damage completely
            health -= damage;
            document.getElementById('health').textContent = health;
            
            if (damage === 0) {
                // Show shield block effect
                createShieldBlockEffect();
            } else {
                // Show damage overlay
                const damageOverlay = document.getElementById('damageOverlay');
                damageOverlay.classList.add('active');
                
                // Remove overlay after short time
                setTimeout(() => {
                    damageOverlay.classList.remove('active');
                }, 300);
            }
            
            // Make player invulnerable for 1 second
            invulnerable = true;
            setTimeout(() => {
                invulnerable = false;
            }, 1000);
            
            // Check for game over
            if (health <= 0) {
                alert('Game Over! The ghosts caught you!');
                location.reload();
            }
        }
        
        function createShieldBlockEffect() {
            // Create blue shield sparkles when damage is blocked
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.style.position = 'fixed';
                sparkle.style.left = '50%';
                sparkle.style.top = '50%';
                sparkle.style.color = '#4A90E2';
                sparkle.style.fontSize = '24px';
                sparkle.style.pointerEvents = 'none';
                sparkle.style.zIndex = '1000';
                sparkle.textContent = 'üõ°Ô∏è‚ú®';
                sparkle.style.animation = `shieldBlock 0.6s ease-out forwards`;
                sparkle.style.transform = `translate(-50%, -50%) translate(${(Math.random()-0.5)*80}px, ${(Math.random()-0.5)*80}px)`;
                document.body.appendChild(sparkle);
                
                setTimeout(() => sparkle.remove(), 600);
            }
        }
        
        function checkStairs() {
            stairs.forEach(stair => {
                const distance = player.position.distanceTo(stair.position);
                if (distance < 2 && stair.userData.from === currentFloor) {
                    changeFloor(stair.userData.to);
                }
            });
        }
        
        function changeFloor(newFloor) {
            currentFloor = newFloor;
            
            // Move player to new floor
            const floorY = floorConfigs[currentFloor].y + 1;
            player.position.y = floorY;
            camera.position.y = floorY + 1.5;
            
            // Update UI
            document.getElementById('currentFloor').textContent = floorConfigs[currentFloor].name;
            const remainingGhosts = ghosts.filter(g => g.userData.floor === currentFloor && !g.userData.caught).length;
            document.getElementById('floorGhosts').textContent = remainingGhosts;
            
            // Update ghost visibility
            updateGhostVisibility();
        }
        
        function animateGhosts() {
            ghosts.forEach(ghost => {
                if (ghost.visible && !ghost.userData.caught) {
                    // Float animation
                    ghost.userData.time += 0.02;
                    ghost.position.y = ghost.userData.originalY + Math.sin(ghost.userData.time) * 0.3;
                    ghost.rotation.y += 0.01;
                    
                    // Chase player if on same floor
                    if (ghost.userData.floor === currentFloor) {
                        const direction = new THREE.Vector3();
                        direction.subVectors(player.position, ghost.position);
                        direction.y = 0; // Keep horizontal movement only
                        direction.normalize();
                        
                        // Move towards player slowly
                        ghost.position.x += direction.x * ghost.userData.chaseSpeed;
                        ghost.position.z += direction.z * ghost.userData.chaseSpeed;
                        
                        // Keep ghosts within bounds
                        const bounds = 18;
                        ghost.position.x = Math.max(-bounds, Math.min(bounds, ghost.position.x));
                        ghost.position.z = Math.max(-13, Math.min(13, ghost.position.z));
                    }
                }
            });
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            animateGhosts();
            
            renderer.render(scene, camera);
        }
        
        // Initialize the game
        init();
    </script>
</body>
</html>